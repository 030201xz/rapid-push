# ddd_use_case_generator 使用实例

通过结构化的数据，生成 Application 层 use-case

## Prompt

### 调用 `domain_aggregate_analyzer` 工具，获取聚合根信息

调用 skills-mcp 内置的 `ddd_domain_aggregate_analyzer` 工具, 获取领域信息

路径: 

### 调用 `ddd_use_case_generator` 工具，生成 use-case 代码

根据从 `ddd_domain_aggregate_analyzer` 获取的信息，调用 `ddd_use_case_generator` 工具，生成 use-case 代码

生成路径:



## use-case vs service

### 本质关系

```
Application Service ≈ 多个 Use Case 的聚合容器

UserService = RegisterUseCase + UpdateProfileUseCase + DeleteUseCase + ...
```

### 优劣对比

| 方面 | Application Service | Use Case |
|------|-------------------|----------|
| **文件数量** | 少（一个服务文件） | 多（每个用例一个目录） |
| **单一职责** | ❌ 容易膨胀成 God Class | ✅ 天然隔离 |
| **测试** | 需要 mock 整个服务 | 独立测试每个用例 |
| **团队协作** | 容易冲突 | 不同人改不同目录 |
| **依赖注入** | 注入整个服务 | 精准注入单个 Handler |
| **CQRS 适配** | ❌ 读写混在一起 | ✅ 天然分离 Command/Query |

### 你的项目现状

你正在从 **Application Service 风格** 演进到 **Use Case 风格**：

```
旧：cqrs/user/commands/register.handler.ts  ← 按技术分层
新：use-cases/user/mutations/register/      ← 按用例聚合
```

### 一句话总结

> **Application Service 是"胖服务"，Use Case 是"瘦用例"**
> 
> Use Case = 把 Application Service 的每个方法拆成独立模块

### 我的建议

se Case 风格更符合：
- **CQRS 模式**（Command/Query 天然分离）
- **单一职责原则**
- **模块化开发**（一个人负责一个用例）