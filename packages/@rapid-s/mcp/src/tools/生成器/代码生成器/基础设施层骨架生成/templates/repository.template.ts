/**
 * Repository 实现模板渲染器
 */
import type { GeneratorContext } from "../core";

/**
 * 渲染 Repository 实现模板
 */
export function renderRepositoryTemplate(context: GeneratorContext): string {
  const {
    aggregateName,
    aggregateKebab,
    mutations,
    queries,
    domainRelativePath,
  } = context;

  // 生成导入语句
  const imports: string[] = [];

  // Mutation 导入
  for (const mutation of mutations) {
    const className = generateClassName(mutation.methodName, "Mutation");
    imports.push(
      `import { ${className} } from "./mutations/${mutation.operationName}.mutation";`
    );
  }

  // Query 导入
  for (const query of queries) {
    const className = generateClassName(query.methodName, "Query");
    imports.push(
      `import { ${className} } from "./queries/${query.operationName}.query";`
    );
  }

  // 生成构造函数参数
  const constructorParams: string[] = [];
  const allMethods = [...mutations, ...queries];

  for (const method of mutations) {
    const className = generateClassName(method.methodName, "Mutation");
    const propName = toCamelCase(className);
    constructorParams.push(`    private readonly ${propName}: ${className},`);
  }

  for (const method of queries) {
    const className = generateClassName(method.methodName, "Query");
    const propName = toCamelCase(className);
    constructorParams.push(`    private readonly ${propName}: ${className},`);
  }

  // 生成方法实现
  const methodImpls: string[] = [];

  for (const mutation of mutations) {
    const className = generateClassName(mutation.methodName, "Mutation");
    const propName = toCamelCase(className);
    const paramsStr = mutation.parameters.map((p) => p.name).join(", ");

    methodImpls.push("");
    methodImpls.push(`  async ${mutation.methodName}(${formatParams(mutation.parameters)}): ${mutation.returnType} {`);
    methodImpls.push(`    return this.${propName}.execute(${paramsStr});`);
    methodImpls.push("  }");
  }

  for (const query of queries) {
    const className = generateClassName(query.methodName, "Query");
    const propName = toCamelCase(className);
    const paramsStr = query.parameters.map((p) => p.name).join(", ");

    methodImpls.push("");
    methodImpls.push(`  async ${query.methodName}(${formatParams(query.parameters)}): ${query.returnType} {`);
    methodImpls.push(`    return this.${propName}.execute(${paramsStr});`);
    methodImpls.push("  }");
  }

  // 收集所有需要导入的类型
  const allTypes = new Set<string>();
  for (const method of [...mutations, ...queries]) {
    // 从参数中提取类型
    for (const param of method.parameters) {
      const baseType = extractBaseType(param.type);
      if (!isPrimitiveType(baseType)) {
        allTypes.add(baseType);
      }
    }
    // 从返回类型中提取类型
    const returnBaseType = extractBaseType(method.returnType);
    if (!isPrimitiveType(returnBaseType)) {
      allTypes.add(returnBaseType);
    }
  }

  // 构建类型导入语句
  const typeImports = allTypes.size > 0
    ? `import type { ${Array.from(allTypes).join(", ")} } from "${domainRelativePath}";`
    : "";

  const lines: string[] = [
    "/**",
    ` * ${aggregateName} Repository 实现`,
    " *",
    ` * 继承领域层定义的 I${aggregateName}Repository`,
    " *",
    " * @generated by repository-implementation-generator",
    " * @keep-reason TODO: 完善实现后移除 .keep 后缀",
    " */",
    "",
    `import { injectable } from "tsyringe";`,
    "",
    `import {`,
    `  I${aggregateName}Repository,`,
    ...(typeImports ? [`  ${Array.from(allTypes).join(",\n  ")},`] : []),
    `} from "${domainRelativePath}";`,
    "",
    ...imports,
    "",
    "/**",
    ` * ${aggregateName} Repository 实现`,
    " */",
    "@injectable()",
    `export class ${aggregateName}Repository extends I${aggregateName}Repository {`,
    "  constructor(",
    ...constructorParams,
    "  ) {",
    "    super();",
    "  }",
    ...methodImpls,
    "}",
    "",
  ];

  return lines.join("\n");
}

/**
 * 提取基础类型名
 */
function extractBaseType(typeStr: string): string {
  return typeStr
    .replace(/Promise<(.+)>/g, "$1")
    .replace(/\s*\|\s*null/g, "")
    .replace(/\s*\|\s*undefined/g, "")
    .replace(/Array<(.+)>/g, "$1")
    .replace(/\[\]/g, "")
    .trim();
}

/**
 * 是否为原始类型
 */
function isPrimitiveType(type: string): boolean {
  const primitives = [
    "string",
    "number",
    "boolean",
    "void",
    "null",
    "undefined",
    "any",
    "unknown",
    "never",
  ];
  return primitives.includes(type.toLowerCase());
}

/**
 * 生成类名
 */
function generateClassName(methodName: string, suffix: string): string {
  const capitalizedMethod =
    methodName.charAt(0).toUpperCase() + methodName.slice(1);
  return `${capitalizedMethod}${suffix}`;
}

/**
 * 转为 camelCase
 */
function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

/**
 * 格式化参数列表
 */
function formatParams(
  params: Array<{ name: string; type: string; isOptional: boolean }>
): string {
  return params
    .map((p) => `${p.name}${p.isOptional ? "?" : ""}: ${p.type}`)
    .join(", ");
}
